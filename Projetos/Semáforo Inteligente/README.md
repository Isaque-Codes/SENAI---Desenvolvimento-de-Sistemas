# üö¶ Sem√°foro Adaptativo com L√≥gica N√£o-Bloqueante

Este projeto √© um exerc√≠cio de l√≥gica de programa√ß√£o intensiva, implementado em C/C++ para as plataformas Arduino/ESP32. O objetivo foi construir mais do que um simples sem√°foro; o sistema √© um **controlador de tr√°fego adaptativo**, capaz de alterar seu comportamento em tempo real com base em uma entrada externa.

A complexidade do projeto n√£o est√° apenas em alternar luzes, mas em gerenciar m√∫ltiplos processos (temporiza√ß√£o, leitura de bot√£o, atualiza√ß√£o de display) de forma simult√¢nea e responsiva, utilizando uma arquitetura de software n√£o-bloqueante.

---

## ‚öôÔ∏è Arquitetura e L√≥gica Implementada

O sistema √© constru√≠do sobre tr√™s pilares l√≥gicos que operam em conjunto a cada ciclo do `loop()`.

### 1. M√°quina de Estados Finitos (Controle do Sem√°foro)

O n√∫cleo do sistema √© uma m√°quina de estados que gerencia as fases do sem√°foro (Vermelho, Verde, Amarelo). A transi√ß√£o entre os estados √© controlada pela fun√ß√£o `millis()`, garantindo que o microcontrolador permane√ßa livre para executar outras tarefas.

> **Ponto Destaque Secund√°rio: Gerenciamento de Estado Adaptativo -**
> A m√°quina de estados foi projetada para ser flex√≠vel. Durante a fase verde, o c√≥digo verifica uma flag booleana (`alteredTime`) para decidir qual l√≥gica de tempo aplicar. Isso permite que o sistema opere com seu tempo padr√£o ou mude para um novo tempo recalculado dinamicamente, sem quebrar a sequ√™ncia da m√°quina de estados.
> ```c++
> // Fase verde (com l√≥gica adaptativa)
> else if (trafficLightPhase == 1)
> {
>   // Se o tempo n√£o foi alterado, usa o tempo padr√£o (greenTime).
>   // Se foi alterado, usa o novo tempo recalculado (updatedRemainingTime).
>   if (alteredTime == false)
>   {
>     remainingTime = greenTime - (currentTime - beginTime);
>   }
>   else
>   {
>     remainingTime = updatedRemainingTime - (currentTime - beginTime);
>   }
>   // ... transi√ß√£o para a pr√≥xima fase ...
> }
> ```
> Esta abordagem com uma flag de estado desacopla a l√≥gica de temporiza√ß√£o da l√≥gica de transi√ß√£o, tornando o sistema modular e f√°cil de expandir.

### 2. L√≥gica Adaptativa (O C√©rebro do Sistema)

Esta √© a funcionalidade central que torna o sem√°foro "inteligente". O sistema monitora um bot√£o, mas a l√≥gica de interrup√ß√£o s√≥ √© acionada durante a fase verde. Ao detectar o pressionar, ele n√£o muda de fase imediatamente. Em vez disso, ele executa uma l√≥gica de rec√°lculo complexa.

> **Ponto Destaque Principal: Rec√°lculo Din√¢mico e Proporcional de Tempo -**
> O cora√ß√£o da l√≥gica adaptativa reside em um bloco condicional aninhado que s√≥ √© executado sob tr√™s condi√ß√µes: o bot√£o foi pressionado, a fase atual √© a verde e o tempo ainda n√£o foi alterado neste ciclo.
>
> 1.  **C√°lculo de Progresso:** Primeiro, ele calcula quanto tempo do sinal verde j√° se passou (`progress = greenTime - remainingTime`).
> 2.  **L√≥gica Escalonada:** Em seguida, ele usa uma s√©rie de `if-else if` para aplicar uma redu√ß√£o de tempo proporcional. Quanto mais cedo o bot√£o √© pressionado (maior `remainingTime`), maior √© a "acelera√ß√£o" do ciclo.
> 3.  **Atualiza√ß√£o Sistem√°tica:** Ao decidir a nova dura√ß√£o, ele atualiza todas as vari√°veis de estado relevantes (`alteredTime`, `newGreenTime`, `remainingTime`, `updatedRemainingTime`) e, crucialmente, **reseta o cron√¥metro da fase** (`beginTime = currentTime`). Isso garante que a contagem regressiva continue de forma suave a partir do novo valor, sem saltos ou inconsist√™ncias.
> ```c++
> // A l√≥gica de rec√°lculo s√≥ √© acionada se o bot√£o for pressionado,
> // durante a fase verde e se o tempo ainda n√£o foi alterado.
> if (!stateButton && trafficLightPhase == 1 && alteredTime == false)
> {
>   progress = (greenTime - remainingTime);
>
>   // Quanto mais cedo o bot√£o for pressionado, maior a redu√ß√£o de tempo.
>   if (remainingTime > (greenTime * 75) / 100)
>   {
>     alteredTime = true;
>     newGreenTime = (greenTime * 60) / 100;
>     remainingTime = newGreenTime - progress;
>     updatedRemainingTime = remainingTime;
>     beginTime = currentTime; // Reseta o cron√¥metro com o novo tempo.
>   }
>   else if (/* ... outras condi√ß√µes ... */)
>   // ...
> }
> ```

### 3. Tratamento de Hardware (Robustez)

Para garantir a confiabilidade do sistema, foi implementado um tratamento de **debounce** para o bot√£o de entrada. Uma l√≥gica baseada em `millis()` ignora as flutua√ß√µes el√©tricas de um √∫nico aperto de bot√£o, garantindo que a l√≥gica adaptativa seja acionada apenas uma vez, de forma limpa e intencional.

---

## üõ†Ô∏è Conceitos Aplicados

*   **Programa√ß√£o Concorrente Simulada:** Gerenciamento de m√∫ltiplas tarefas (temporiza√ß√£o, input, output) sem o uso de `delay()`.
*   **M√°quinas de Estado Finito (FSM):** Controle de fluxo sequencial com l√≥gica de transi√ß√£o baseada em estado e tempo.
*   **L√≥gica Condicional Complexa:** Tomada de decis√£o em tempo real baseada em m√∫ltiplas vari√°veis de estado (`trafficLightPhase`, `alteredTime`, `lastAction`).
*   **Algoritmos de Temporiza√ß√£o Din√¢mica:** Rec√°lculo de tempo de execu√ß√£o com base em eventos externos.
*   **Intera√ß√£o Hardware-Software:** Integra√ß√£o de LEDs, display LCD I2C e bot√µes.
*   **Debounce de Bot√£o:** Implementa√ß√£o de filtro de ru√≠do por software para entradas digitais.